const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["assets/dgty7ziunhhq6vyd.js", "assets/mna1wiucqak6lqzp.js", "assets/lwme42j7zzyr3q7j.js", "assets/bq4rrqi54riy5k2e.js", "assets/root-ey6kd8gf.css", "assets/conversation-small-fu0y35oi.css", "assets/n9hd7wgx8jqnonth.js", "assets/d3y72ugnrmac5z1v.js", "assets/sec85tgb7vkty17r.js", "assets/fzrn137102spawew.js", "assets/e9lafxuzyeh4418f.js", "assets/eqjyr70wex3y5gfz.js"]))) => i.map(i => d[i]);
import {
    Y as _t,
    ab as Tn,
    bM as kn,
    a1 as En,
    w as jn,
    M as Pn,
    h as $e,
    L as Ue,
    P as E,
    a as R,
    a6 as Rt,
    d5 as An,
    cE as Xe,
    aB as Dt,
    cb as _n,
    gO as Rn,
    gP as he,
    gQ as Dn,
    gR as Nt,
    gS as _e,
    gT as Re,
    gU as Nn,
    gV as On,
    gW as Fn,
    gX as Wn,
    gY as Bn,
    d4 as Hn,
    d as Q,
    W as Ln,
    n as $n,
    as as Un,
    a0 as Ot,
    k as Ze,
    bs as me,
    bz as Ft,
    bA as Wt,
    cr as Ie,
    aj as Te,
    N as Kn,
    bW as zn,
    dJ as qn,
    dH as Gn,
    bY as k,
    cp as Ke,
    bZ as Vn,
    fQ as Qn,
    ci as pe,
    S as we,
    r as Bt,
    av as be,
    cs as Yn,
    dt as Jn,
    E as Xn,
    B as De,
    aD as Zn,
    b_ as ze,
    U as es
} from "./bq4rrqi54riy5k2e.js";
import {
    r as p,
    j as r,
    M as I,
    c as L,
    R as q,
    l as G,
    m as ts,
    L as ns,
    a as ss,
    d as et
} from "./mna1wiucqak6lqzp.js";
import {
    x as Ht,
    w as tt,
    cp as as,
    B as os,
    hp as nt,
    hq as st,
    n6 as at,
    lp as rs,
    ng as is,
    gy as ls,
    lm as cs,
    lj as us,
    mj as ds,
    nh as ms,
    ni as ps,
    aW as V,
    ay as P,
    nj as Lt,
    ar as ft,
    as as ee,
    at as ke,
    aD as fs,
    b2 as gs,
    b3 as hs,
    aG as vs,
    aH as $t,
    aI as ye,
    aJ as te,
    aV as xs,
    b4 as j,
    nk as _,
    b5 as Ss,
    aK as ws,
    aL as bs,
    aM as ys,
    aO as Ut,
    aN as Ms,
    av as Cs,
    aS as Is,
    aT as Ts,
    aX as ks,
    aY as Es,
    nl as js,
    nm as Ps,
    nn as As,
    no as _s,
    a_ as gt,
    np as Kt,
    a$ as Rs,
    aU as Ds,
    b1 as Ns,
    nq as Os,
    nr as Fs,
    ns as Ws,
    nt as zt,
    nu as Bs,
    nv as Hs,
    nw as Ne,
    nx as Ls,
    iv as $s,
    ny as Us,
    nz as qt,
    n5 as Ks,
    hT as zs,
    nA as qs,
    nB as Gs,
    gA as Vs,
    bY as Qs,
    ee as Ys,
    dD as Js,
    W as ot,
    gd as Xs,
    nC as Zs,
    nD as ea,
    l as Gt,
    bX as Ee,
    mP as rt,
    eZ as Vt,
    cz as ta,
    U as H,
    cA as ht,
    dc as na,
    ai as sa,
    G as Qt,
    nE as it,
    nF as Yt,
    nG as Jt,
    nH as Xt,
    nI as aa,
    bD as oa,
    aq as Zt,
    N as Me,
    l$ as en,
    mO as tn,
    nJ as nn,
    nK as sn,
    fp as ra,
    nL as ia,
    bl as an,
    d5 as la,
    dR as ca,
    z as lt,
    nM as ua,
    fv as on,
    nN as da,
    m0 as ma,
    k0 as pa,
    f$ as ct,
    jj as fa,
    lT as rn,
    $ as ga,
    nO as ha,
    lU as va,
    h0 as vt,
    nP as xa,
    f_ as xt,
    ji as Sa,
    fU as wa,
    k5 as ba,
    k6 as ya,
    lS as Ma,
    ba as Ca,
    lV as Ia
} from "./lwme42j7zzyr3q7j.js";
import {
    c as Ta,
    b as ka,
    T as Ea
} from "./cxz91putlw7pmfk2.js";
import {
    t as ja,
    u as Pa
} from "./m0wlwtibo8yb2c2h.js";
import {
    P as ne,
    a as oe,
    D as Aa,
    b as _a,
    T as ve,
    p as Ra,
    M as Da,
    k as qe,
    c as St,
    S as Na,
    E as Oa,
    d as Fa,
    e as Wa,
    g as Ba,
    i as Ha,
    n as La
} from "./hx3p6g5v1c632c0c.js";
const ln = Ht.DesktopBrowserExtensionAnnouncement,
    cn = Ht.DesktopBrowserExtensionReactiveAnnouncement,
    $a = 5,
    ut = "https://chromewebstore.google.com/detail/searchgpt/ejcfepkfckglbgocfkanmcdngdijcgld";

function Ua({
    announcementKey: e = ln,
    onClose: t
}) {
    p.useEffect(() => {
        E.logEventWithStatsig(R.chatgptBrowserExtensionAnnouncementShown, "chatgpt_browser_extension_announcement_shown")
    }, []);
    const {
        markAsViewed: n
    } = tt(e), s = p.useCallback(() => {
        n(), E.logEventWithStatsig(R.chatgptBrowserExtensionAnnouncementClosed, "chatgpt_browser_extension_announcement_closed"), t && t()
    }, [n, t]), a = p.useCallback(() => {
        E.logEventWithStatsig(R.chatgptBrowserExtensionAnnouncementCTAClicked, "chatgpt_browser_extension_announcement_cta_clicked"), n(), t && t()
    }, [n, t]);
    return r.jsx(Ka, {
        downloadUrl: ut,
        announcementKey: e,
        handleCTAClicked: a,
        handleClose: s
    })
}

function Qr({
    onClose: e
}) {
    return Ua({
        announcementKey: cn,
        onClose: e
    })
}

function Ka({
    downloadUrl: e,
    announcementKey: t,
    handleCTAClicked: n,
    handleClose: s
}) {
    const a = () => {
            n(), window.open(e)
        },
        o = r.jsxs("div", {
            className: "flex-grow",
            children: [r.jsx("div", {
                className: "mb-0.5 font-semibold",
                children: r.jsx(I, {
                    id: "uAZwaE",
                    defaultMessage: "Use ChatGPT for every search"
                })
            }), r.jsx("span", {
                className: "text-token-text-secondary",
                children: r.jsx(I, {
                    id: "+wTq4L",
                    defaultMessage: "Download the Chrome extension to switch your default search engine to ChatGPT, and get instant answers from trusted sources with every search."
                })
            })]
        });
    return r.jsx(os, {
        onPrimaryCtaClick: a,
        primaryCtaText: r.jsx(I, {
            id: "x9mKG0",
            defaultMessage: "Get Extension"
        }),
        onDismiss: () => s(t),
        content: o
    })
}

function un(e) {
    const {
        value: t
    } = Rt("2634628831"), n = An(() => document.documentElement.dataset.searchExtension === "1"), s = nt(e.clientThreadId), a = st(s, Xe.Search), i = !Dt() ? .includes(_n.SearchToolHoldout), {
        userIsInSearchHoldoutWithWebDisabled: l
    } = Ta();
    return at() && !n && a && i && !l && t
}

function Yr(e) {
    const t = un(e),
        n = za(),
        s = tt(ln);
    return s.eligible && !s.isLoading && t && n && !_t(e.clientThreadId) && e.conversationMode ? .kind === Tn.PrimaryAssistant
}

function Jr(e) {
    const t = un(e),
        n = kn(e.clientThreadId),
        s = En(e.clientThreadId, n),
        a = as(s, c => c.role === jn.User);
    var o = !1;
    const i = a ? .messages[0] ? .message;
    if (i ? .content.content_type === Pn.Text) {
        const c = i ? .content.parts[0] ? .toLowerCase();
        c && (o = c.includes("chrome extension") || c.includes("default search"))
    }
    const l = tt(cn);
    return l.eligible && !l.isLoading && t && o
}

function Xr(e) {
    const t = $e.getItem(Ue.SearchSettings) ? ? {};
    t.hasSearchedMinTimes || (t.searchMessageIds || (t.searchMessageIds = []), t.searchMessageIds.includes(e) || (t.searchMessageIds.push(e), t.searchMessageIds.length >= $a && (t.hasSearchedMinTimes = !0, delete t.searchMessageIds), $e.setItem(Ue.SearchSettings, t)))
}

function za() {
    return ($e.getItem(Ue.SearchSettings) ? ? {}).hasSearchedMinTimes === !0
}

function qa({
    task: e
}) {
    const t = L(),
        n = !1,
        s = rs(e),
        {
            clearSystemHintModeTrigger: a
        } = ka();
    return p.useEffect(() => {
        e.notificationStatus ? .recentlyCompleted && !e.notificationStatus ? .notificationSent && !n && (s(), is(e, t), a(ls.Research), cs.setTaskNotificationSent(e.taskId))
    }, [e, t, s, n, a]), r.jsx(q.Fragment, {})
}

function Ga() {
    const e = us(ds.getAllTasksOrdered);
    return ms(), e.length ? r.jsx(r.Fragment, {
        children: e.map(t => r.jsx(qa, {
            task: t
        }, t.taskId))
    }) : null
}
const dn = { ...ts
    },
    Va = dn.useInsertionEffect,
    Qa = Va || (e => e());

function mn(e) {
    const t = p.useRef(() => {});
    return Qa(() => {
        t.current = e
    }), p.useCallback(function() {
        for (var n = arguments.length, s = new Array(n), a = 0; a < n; a++) s[a] = arguments[a];
        return t.current == null ? void 0 : t.current(...s)
    }, [])
}
var Ge = typeof document < "u" ? p.useLayoutEffect : p.useEffect;
let wt = !1,
    Ya = 0;
const bt = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + Ya++;

function Ja() {
    const [e, t] = p.useState(() => wt ? bt() : void 0);
    return Ge(() => {
        e == null && t(bt())
    }, []), p.useEffect(() => {
        wt = !0
    }, []), e
}
const Xa = dn.useId,
    Za = Xa || Ja;

function eo() {
    const e = new Map;
    return {
        emit(t, n) {
            var s;
            (s = e.get(t)) == null || s.forEach(a => a(n))
        },
        on(t, n) {
            e.set(t, [...e.get(t) || [], n])
        },
        off(t, n) {
            var s;
            e.set(t, ((s = e.get(t)) == null ? void 0 : s.filter(a => a !== n)) || [])
        }
    }
}
const to = p.createContext(null),
    no = p.createContext(null),
    so = () => {
        var e;
        return ((e = p.useContext(to)) == null ? void 0 : e.id) || null
    },
    ao = () => p.useContext(no),
    oo = "data-floating-ui-focusable";

function ro(e) {
    const {
        open: t = !1,
        onOpenChange: n,
        elements: s
    } = e, a = Za(), o = p.useRef({}), [i] = p.useState(() => eo()), l = so() != null, [c, m] = p.useState(s.reference), f = mn((d, g, v) => {
        o.current.openEvent = d ? g : void 0, i.emit("openchange", {
            open: d,
            event: g,
            reason: v,
            nested: l
        }), n ? .(d, g, v)
    }), h = p.useMemo(() => ({
        setPositionReference: m
    }), []), u = p.useMemo(() => ({
        reference: c || s.reference || null,
        floating: s.floating || null,
        domReference: s.reference
    }), [c, s.reference, s.floating]);
    return p.useMemo(() => ({
        dataRef: o,
        open: t,
        onOpenChange: f,
        elements: u,
        events: i,
        floatingId: a,
        refs: h
    }), [t, f, u, i, a, h])
}

function io(e) {
    e === void 0 && (e = {});
    const {
        nodeId: t
    } = e, n = ro({ ...e,
        elements: {
            reference: null,
            floating: null,
            ...e.elements
        }
    }), s = e.rootContext || n, a = s.elements, [o, i] = p.useState(null), [l, c] = p.useState(null), f = a ? .reference || o, h = p.useRef(null), u = ao();
    Ge(() => {
        f && (h.current = f)
    }, [f]);
    const d = Rn({ ...e,
            elements: { ...a,
                ...l && {
                    reference: l
                }
            }
        }),
        g = p.useCallback(S => {
            const y = he(S) ? {
                getBoundingClientRect: () => S.getBoundingClientRect(),
                contextElement: S
            } : S;
            c(y), d.refs.setReference(y)
        }, [d.refs]),
        v = p.useCallback(S => {
            (he(S) || S === null) && (h.current = S, i(S)), (he(d.refs.reference.current) || d.refs.reference.current === null || S !== null && !he(S)) && d.refs.setReference(S)
        }, [d.refs]),
        x = p.useMemo(() => ({ ...d.refs,
            setReference: v,
            setPositionReference: g,
            domReference: h
        }), [d.refs, v, g]),
        b = p.useMemo(() => ({ ...d.elements,
            domReference: f
        }), [d.elements, f]),
        M = p.useMemo(() => ({ ...d,
            ...s,
            refs: x,
            elements: b,
            nodeId: t
        }), [d, x, b, t, s]);
    return Ge(() => {
        s.dataRef.current.floatingContext = M;
        const S = u ? .nodesRef.current.find(y => y.id === t);
        S && (S.context = M)
    }), p.useMemo(() => ({ ...d,
        context: M,
        refs: x,
        elements: b
    }), [d, x, b, M])
}
const yt = "active",
    Mt = "selected";

function Oe(e, t, n) {
    const s = new Map,
        a = n === "item";
    let o = e;
    if (a && e) {
        const {
            [yt]: i, [Mt]: l, ...c
        } = e;
        o = c
    }
    return { ...n === "floating" && {
            tabIndex: -1,
            [oo]: ""
        },
        ...o,
        ...t.map(i => {
            const l = i ? i[n] : null;
            return typeof l == "function" ? e ? l(e) : null : l
        }).concat(e).reduce((i, l) => (l && Object.entries(l).forEach(c => {
            let [m, f] = c;
            if (!(a && [yt, Mt].includes(m)))
                if (m.indexOf("on") === 0) {
                    if (s.has(m) || s.set(m, []), typeof f == "function") {
                        var h;
                        (h = s.get(m)) == null || h.push(f), i[m] = function() {
                            for (var u, d = arguments.length, g = new Array(d), v = 0; v < d; v++) g[v] = arguments[v];
                            return (u = s.get(m)) == null ? void 0 : u.map(x => x(...g)).find(x => x !== void 0)
                        }
                    }
                } else i[m] = f
        }), i), {})
    }
}

function lo(e) {
    e === void 0 && (e = []);
    const t = e.map(l => l ? .reference),
        n = e.map(l => l ? .floating),
        s = e.map(l => l ? .item),
        a = p.useCallback(l => Oe(l, e, "reference"), t),
        o = p.useCallback(l => Oe(l, e, "floating"), n),
        i = p.useCallback(l => Oe(l, e, "item"), s);
    return p.useMemo(() => ({
        getReferenceProps: a,
        getFloatingProps: o,
        getItemProps: i
    }), [a, o, i])
}

function Ct(e, t) {
    return { ...e,
        rects: { ...e.rects,
            floating: { ...e.rects.floating,
                height: t
            }
        }
    }
}
const co = e => ({
    name: "inner",
    options: e,
    async fn(t) {
        const {
            listRef: n,
            overflowRef: s,
            onFallbackChange: a,
            offset: o = 0,
            index: i = 0,
            minItemsVisible: l = 4,
            referenceOverflowThreshold: c = 0,
            scrollRef: m,
            ...f
        } = Dn(e, t), {
            rects: h,
            elements: {
                floating: u
            }
        } = t, d = n.current[i], g = m ? .current || u, v = u.clientTop || g.clientTop, x = u.clientTop !== 0, b = g.clientTop !== 0, M = u === g;
        if (!d) return {};
        const S = { ...t,
                ...await Nt(-d.offsetTop - u.clientTop - h.reference.height / 2 - d.offsetHeight / 2 - o).fn(t)
            },
            y = await _e(Ct(S, g.scrollHeight + v + u.clientTop), f),
            D = await _e(S, { ...f,
                elementContext: "reference"
            }),
            A = Re(0, y.top),
            O = S.y + A,
            C = Nn(Re(0, g.scrollHeight + (x && M || b ? v * 2 : 0) - A - Re(0, y.bottom)));
        if (g.style.maxHeight = C + "px", g.scrollTop = A, a) {
            const T = g.scrollHeight > g.offsetHeight && g.offsetHeight < d.offsetHeight * l - 1 || D.top >= -c || D.bottom >= -c;
            G.flushSync(() => a(T))
        }
        return s && (s.current = await _e(Ct({ ...S,
            y: O
        }, g.offsetHeight + v + u.clientTop), f)), {
            y: O
        }
    }
});

function uo(e, t) {
    const {
        open: n,
        elements: s
    } = e, {
        enabled: a = !0,
        overflowRef: o,
        scrollRef: i,
        onChange: l
    } = t, c = mn(l), m = p.useRef(!1), f = p.useRef(null), h = p.useRef(null);
    p.useEffect(() => {
        if (!a) return;

        function d(v) {
            if (v.ctrlKey || !g || o.current == null) return;
            const x = v.deltaY,
                b = o.current.top >= -.5,
                M = o.current.bottom >= -.5,
                S = g.scrollHeight - g.clientHeight,
                y = x < 0 ? -1 : 1,
                D = x < 0 ? "max" : "min";
            g.scrollHeight <= g.clientHeight || (!b && x > 0 || !M && x < 0 ? (v.preventDefault(), G.flushSync(() => {
                c(A => A + Math[D](x, S * y))
            })) : /firefox/i.test(ps()) && (g.scrollTop += x))
        }
        const g = i ? .current || s.floating;
        if (n && g) return g.addEventListener("wheel", d), requestAnimationFrame(() => {
            f.current = g.scrollTop, o.current != null && (h.current = { ...o.current
            })
        }), () => {
            f.current = null, h.current = null, g.removeEventListener("wheel", d)
        }
    }, [a, n, s.floating, o, i, c]);
    const u = p.useMemo(() => ({
        onKeyDown() {
            m.current = !0
        },
        onWheel() {
            m.current = !1
        },
        onPointerMove() {
            m.current = !1
        },
        onScroll() {
            const d = i ? .current || s.floating;
            if (!(!o.current || !d || !m.current)) {
                if (f.current !== null) {
                    const g = d.scrollTop - f.current;
                    (o.current.bottom < -.5 && g < -1 || o.current.top < -.5 && g > 1) && G.flushSync(() => c(v => v + g))
                }
                requestAnimationFrame(() => {
                    f.current = d.scrollTop
                })
            }
        }
    }), [s.floating, c, o, i]);
    return p.useMemo(() => a ? {
        floating: u
    } : {}, [a, u])
}
let re = p.createContext({
    styles: void 0,
    setReference: () => {},
    setFloating: () => {},
    getReferenceProps: () => ({}),
    getFloatingProps: () => ({}),
    slot: {}
});
re.displayName = "FloatingContext";
let dt = p.createContext(null);
dt.displayName = "PlacementContext";

function mo(e) {
    return p.useMemo(() => e ? typeof e == "string" ? {
        to: e
    } : e : null, [e])
}

function po() {
    return p.useContext(re).setReference
}

function fo() {
    return p.useContext(re).getReferenceProps
}

function go() {
    let {
        getFloatingProps: e,
        slot: t
    } = p.useContext(re);
    return p.useCallback((...n) => Object.assign({}, e(...n), {
        "data-anchor": t.anchor
    }), [e, t])
}

function ho(e = null) {
    e === !1 && (e = null), typeof e == "string" && (e = {
        to: e
    });
    let t = p.useContext(dt),
        n = p.useMemo(() => e, [JSON.stringify(e, (a, o) => {
            var i;
            return (i = o ? .outerHTML) != null ? i : o
        })]);
    V(() => {
        t ? .(n ? ? null)
    }, [t, n]);
    let s = p.useContext(re);
    return p.useMemo(() => [s.setFloating, e ? s.styles : {}], [s.setFloating, e, s.styles])
}
let It = 4;

function vo({
    children: e,
    enabled: t = !0
}) {
    let [n, s] = p.useState(null), [a, o] = p.useState(0), i = p.useRef(null), [l, c] = p.useState(null);
    xo(l);
    let m = t && n !== null && l !== null,
        {
            to: f = "bottom",
            gap: h = 0,
            offset: u = 0,
            padding: d = 0,
            inner: g
        } = So(n, l),
        [v, x = "center"] = f.split(" ");
    V(() => {
        m && o(0)
    }, [m]);
    let {
        refs: b,
        floatingStyles: M,
        context: S
    } = io({
        open: m,
        placement: v === "selection" ? x === "center" ? "bottom" : `bottom-${x}` : x === "center" ? `${v}` : `${v}-${x}`,
        strategy: "absolute",
        transform: !1,
        middleware: [Nt({
            mainAxis: v === "selection" ? 0 : h,
            crossAxis: u
        }), On({
            padding: d
        }), v !== "selection" && Fn({
            padding: d
        }), v === "selection" && g ? co({ ...g,
            padding: d,
            overflowRef: i,
            offset: a,
            minItemsVisible: It,
            referenceOverflowThreshold: d,
            onFallbackChange(K) {
                var Y, ae;
                if (!K) return;
                let J = S.elements.floating;
                if (!J) return;
                let fe = parseFloat(getComputedStyle(J).scrollPaddingBottom) || 0,
                    ie = Math.min(It, J.childElementCount),
                    w = 0,
                    le = 0;
                for (let F of (ae = (Y = S.elements.floating) == null ? void 0 : Y.childNodes) != null ? ae : [])
                    if (F instanceof HTMLElement) {
                        let $ = F.offsetTop,
                            ge = $ + F.clientHeight + fe,
                            Ae = J.scrollTop,
                            pt = Ae + J.clientHeight;
                        if ($ >= Ae && ge <= pt) ie--;
                        else {
                            le = Math.max(0, Math.min(ge, pt) - Math.max($, Ae)), w = F.clientHeight;
                            break
                        }
                    }
                ie >= 1 && o(F => {
                    let $ = w * ie - le + fe;
                    return F >= $ ? F : $
                })
            }
        }) : null, Wn({
            padding: d,
            apply({
                availableWidth: K,
                availableHeight: Y,
                elements: ae
            }) {
                Object.assign(ae.floating.style, {
                    overflow: "auto",
                    maxWidth: `${K}px`,
                    maxHeight: `min(var(--anchor-max-height, 100vh), ${Y}px)`
                })
            }
        })].filter(Boolean),
        whileElementsMounted: Bn
    }), [y = v, D = x] = S.placement.split("-");
    v === "selection" && (y = "selection");
    let A = p.useMemo(() => ({
            anchor: [y, D].filter(Boolean).join(" ")
        }), [y, D]),
        O = uo(S, {
            overflowRef: i,
            onChange: o
        }),
        {
            getReferenceProps: C,
            getFloatingProps: T
        } = lo([O]),
        se = P(K => {
            c(K), b.setFloating(K)
        });
    return p.createElement(dt.Provider, {
        value: s
    }, p.createElement(re.Provider, {
        value: {
            setFloating: se,
            setReference: b.setReference,
            styles: M,
            getReferenceProps: C,
            getFloatingProps: T,
            slot: A
        }
    }, e))
}

function xo(e) {
    V(() => {
        if (!e) return;
        let t = new MutationObserver(() => {
            let n = window.getComputedStyle(e).maxHeight,
                s = parseFloat(n);
            if (isNaN(s)) return;
            let a = parseInt(n);
            isNaN(a) || s !== a && (e.style.maxHeight = `${Math.ceil(s)}px`)
        });
        return t.observe(e, {
            attributes: !0,
            attributeFilter: ["style"]
        }), () => {
            t.disconnect()
        }
    }, [e])
}

function So(e, t) {
    var n, s, a;
    let o = Fe((n = e ? .gap) != null ? n : "var(--anchor-gap, 0)", t),
        i = Fe((s = e ? .offset) != null ? s : "var(--anchor-offset, 0)", t),
        l = Fe((a = e ? .padding) != null ? a : "var(--anchor-padding, 0)", t);
    return { ...e,
        gap: o,
        offset: i,
        padding: l
    }
}

function Fe(e, t, n = void 0) {
    let s = Lt(),
        a = P((c, m) => {
            if (c == null) return [n, null];
            if (typeof c == "number") return [c, null];
            if (typeof c == "string") {
                if (!m) return [n, null];
                let f = Tt(c, m);
                return [f, h => {
                    let u = pn(c); {
                        let d = u.map(g => window.getComputedStyle(m).getPropertyValue(g));
                        s.requestAnimationFrame(function g() {
                            s.nextFrame(g);
                            let v = !1;
                            for (let [b, M] of u.entries()) {
                                let S = window.getComputedStyle(m).getPropertyValue(M);
                                if (d[b] !== S) {
                                    d[b] = S, v = !0;
                                    break
                                }
                            }
                            if (!v) return;
                            let x = Tt(c, m);
                            f !== x && (h(x), f = x)
                        })
                    }
                    return s.dispose
                }]
            }
            return [n, null]
        }),
        o = p.useMemo(() => a(e, t)[0], [e, t]),
        [i = o, l] = p.useState();
    return V(() => {
        let [c, m] = a(e, t);
        if (l(c), !!m) return m(l)
    }, [e, t]), i
}

function pn(e) {
    let t = /var\((.*)\)/.exec(e);
    if (t) {
        let n = t[1].indexOf(",");
        if (n === -1) return [t[1]];
        let s = t[1].slice(0, n).trim(),
            a = t[1].slice(n + 1).trim();
        return a ? [s, ...pn(a)] : [s]
    }
    return []
}

function Tt(e, t) {
    let n = document.createElement("div");
    t.appendChild(n), n.style.setProperty("margin-top", "0px", "important"), n.style.setProperty("margin-top", e, "important");
    let s = parseFloat(window.getComputedStyle(n).marginTop) || 0;
    return t.removeChild(n), s
}
var wo = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(wo || {}),
    bo = (e => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(bo || {}),
    yo = (e => (e[e.OpenMenu = 0] = "OpenMenu", e[e.CloseMenu = 1] = "CloseMenu", e[e.GoToItem = 2] = "GoToItem", e[e.Search = 3] = "Search", e[e.ClearSearch = 4] = "ClearSearch", e[e.RegisterItem = 5] = "RegisterItem", e[e.UnregisterItem = 6] = "UnregisterItem", e[e.SetButtonElement = 7] = "SetButtonElement", e[e.SetItemsElement = 8] = "SetItemsElement", e))(yo || {});

function We(e, t = n => n) {
    let n = e.activeItemIndex !== null ? e.items[e.activeItemIndex] : null,
        s = Ls(t(e.items.slice()), o => o.dataRef.current.domRef.current),
        a = n ? s.indexOf(n) : null;
    return a === -1 && (a = null), {
        items: s,
        activeItemIndex: a
    }
}
let Mo = {
        1(e) {
            return e.menuState === 1 ? e : { ...e,
                activeItemIndex: null,
                menuState: 1
            }
        },
        0(e) {
            return e.menuState === 0 ? e : { ...e,
                __demoMode: !1,
                menuState: 0
            }
        },
        2: (e, t) => {
            var n, s, a, o, i;
            if (e.menuState === 1) return e;
            let l = { ...e,
                searchQuery: "",
                activationTrigger: (n = t.trigger) != null ? n : 1,
                __demoMode: !1
            };
            if (t.focus === _.Nothing) return { ...l,
                activeItemIndex: null
            };
            if (t.focus === _.Specific) return { ...l,
                activeItemIndex: e.items.findIndex(f => f.id === t.id)
            };
            if (t.focus === _.Previous) {
                let f = e.activeItemIndex;
                if (f !== null) {
                    let h = e.items[f].dataRef.current.domRef,
                        u = Ne(t, {
                            resolveItems: () => e.items,
                            resolveActiveIndex: () => e.activeItemIndex,
                            resolveId: d => d.id,
                            resolveDisabled: d => d.dataRef.current.disabled
                        });
                    if (u !== null) {
                        let d = e.items[u].dataRef.current.domRef;
                        if (((s = h.current) == null ? void 0 : s.previousElementSibling) === d.current || ((a = d.current) == null ? void 0 : a.previousElementSibling) === null) return { ...l,
                            activeItemIndex: u
                        }
                    }
                }
            } else if (t.focus === _.Next) {
                let f = e.activeItemIndex;
                if (f !== null) {
                    let h = e.items[f].dataRef.current.domRef,
                        u = Ne(t, {
                            resolveItems: () => e.items,
                            resolveActiveIndex: () => e.activeItemIndex,
                            resolveId: d => d.id,
                            resolveDisabled: d => d.dataRef.current.disabled
                        });
                    if (u !== null) {
                        let d = e.items[u].dataRef.current.domRef;
                        if (((o = h.current) == null ? void 0 : o.nextElementSibling) === d.current || ((i = d.current) == null ? void 0 : i.nextElementSibling) === null) return { ...l,
                            activeItemIndex: u
                        }
                    }
                }
            }
            let c = We(e),
                m = Ne(t, {
                    resolveItems: () => c.items,
                    resolveActiveIndex: () => c.activeItemIndex,
                    resolveId: f => f.id,
                    resolveDisabled: f => f.dataRef.current.disabled
                });
            return { ...l,
                ...c,
                activeItemIndex: m
            }
        },
        3: (e, t) => {
            let n = e.searchQuery !== "" ? 0 : 1,
                s = e.searchQuery + t.value.toLowerCase(),
                a = (e.activeItemIndex !== null ? e.items.slice(e.activeItemIndex + n).concat(e.items.slice(0, e.activeItemIndex + n)) : e.items).find(i => {
                    var l;
                    return ((l = i.dataRef.current.textValue) == null ? void 0 : l.startsWith(s)) && !i.dataRef.current.disabled
                }),
                o = a ? e.items.indexOf(a) : -1;
            return o === -1 || o === e.activeItemIndex ? { ...e,
                searchQuery: s
            } : { ...e,
                searchQuery: s,
                activeItemIndex: o,
                activationTrigger: 1
            }
        },
        4(e) {
            return e.searchQuery === "" ? e : { ...e,
                searchQuery: "",
                searchActiveItemIndex: null
            }
        },
        5: (e, t) => {
            let n = We(e, s => [...s, {
                id: t.id,
                dataRef: t.dataRef
            }]);
            return { ...e,
                ...n
            }
        },
        6: (e, t) => {
            let n = We(e, s => {
                let a = s.findIndex(o => o.id === t.id);
                return a !== -1 && s.splice(a, 1), s
            });
            return { ...e,
                ...n,
                activationTrigger: 1
            }
        },
        7: (e, t) => e.buttonElement === t.element ? e : { ...e,
            buttonElement: t.element
        },
        8: (e, t) => e.itemsElement === t.element ? e : { ...e,
            itemsElement: t.element
        }
    },
    mt = p.createContext(null);
mt.displayName = "MenuContext";

function je(e) {
    let t = p.useContext(mt);
    if (t === null) {
        let n = new Error(`<${e} /> is missing a parent <Menu /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, je), n
    }
    return t
}

function Co(e, t) {
    return $t(t.type, Mo, e, t)
}
let Io = p.Fragment;

function To(e, t) {
    let {
        __demoMode: n = !1,
        ...s
    } = e, a = p.useReducer(Co, {
        __demoMode: n,
        menuState: n ? 0 : 1,
        buttonElement: null,
        itemsElement: null,
        items: [],
        searchQuery: "",
        activeItemIndex: null,
        activationTrigger: 1
    }), [{
        menuState: o,
        itemsElement: i,
        buttonElement: l
    }, c] = a, m = ke(t);
    fs(o === 0, [l, i], (d, g) => {
        c({
            type: 1
        }), gs(g, hs.Loose) || (d.preventDefault(), l ? .focus())
    });
    let f = P(() => {
            c({
                type: 1
            })
        }),
        h = p.useMemo(() => ({
            open: o === 0,
            close: f
        }), [o, f]),
        u = {
            ref: m
        };
    return q.createElement(vo, null, q.createElement(mt.Provider, {
        value: a
    }, q.createElement(vs, {
        value: $t(o, {
            0: ye.Open,
            1: ye.Closed
        })
    }, te({
        ourProps: u,
        theirProps: s,
        slot: h,
        defaultTag: Io,
        name: "Menu"
    }))))
}
let ko = "button";

function Eo(e, t) {
    var n;
    let s = p.useId(),
        {
            id: a = `headlessui-menu-button-${s}`,
            disabled: o = !1,
            autoFocus: i = !1,
            ...l
        } = e,
        [c, m] = je("Menu.Button"),
        f = fo(),
        h = xs(),
        u = ke(t, po(), P(C => m({
            type: 7,
            element: C
        }))),
        d = P(C => {
            switch (C.key) {
                case j.Space:
                case j.Enter:
                case j.ArrowDown:
                    C.preventDefault(), C.stopPropagation(), G.flushSync(() => m({
                        type: 0
                    })), m({
                        type: 2,
                        focus: _.First
                    });
                    break;
                case j.ArrowUp:
                    C.preventDefault(), C.stopPropagation(), G.flushSync(() => m({
                        type: 0
                    })), m({
                        type: 2,
                        focus: _.Last
                    });
                    break
            }
        }),
        g = P(C => {
            switch (C.key) {
                case j.Space:
                    C.preventDefault();
                    break
            }
        }),
        v = P(C => {
            var T;
            if (Ss(C.currentTarget)) return C.preventDefault();
            o || (c.menuState === 0 ? (G.flushSync(() => m({
                type: 1
            })), (T = c.buttonElement) == null || T.focus({
                preventScroll: !0
            })) : (C.preventDefault(), m({
                type: 0
            })))
        }),
        {
            isFocusVisible: x,
            focusProps: b
        } = ws({
            autoFocus: i
        }),
        {
            isHovered: M,
            hoverProps: S
        } = bs({
            isDisabled: o
        }),
        {
            pressed: y,
            pressProps: D
        } = ys({
            disabled: o
        }),
        A = p.useMemo(() => ({
            open: c.menuState === 0,
            active: y || c.menuState === 0,
            disabled: o,
            hover: M,
            focus: x,
            autofocus: i
        }), [c, M, x, y, o, i]),
        O = Ut(f(), {
            ref: u,
            id: a,
            type: Ms(e, c.buttonElement),
            "aria-haspopup": "menu",
            "aria-controls": (n = c.itemsElement) == null ? void 0 : n.id,
            "aria-expanded": c.menuState === 0,
            disabled: o || void 0,
            autoFocus: i,
            onKeyDown: d,
            onKeyUp: g,
            onClick: v
        }, b, S, D);
    return te({
        mergeRefs: h,
        ourProps: O,
        theirProps: l,
        slot: A,
        defaultTag: ko,
        name: "Menu.Button"
    })
}
let jo = "div",
    Po = ft.RenderStrategy | ft.Static;

function Ao(e, t) {
    var n, s;
    let a = p.useId(),
        {
            id: o = `headlessui-menu-items-${a}`,
            anchor: i,
            portal: l = !1,
            modal: c = !0,
            transition: m = !1,
            ...f
        } = e,
        h = mo(i),
        [u, d] = je("Menu.Items"),
        [g, v] = ho(h),
        x = go(),
        [b, M] = p.useState(null),
        S = ke(t, h ? g : null, P(w => d({
            type: 8,
            element: w
        })), M),
        y = Cs(u.itemsElement);
    h && (l = !0);
    let D = Is(),
        [A, O] = Ts(m, b, D !== null ? (D & ye.Open) === ye.Open : u.menuState === 0);
    ks(A, u.buttonElement, () => {
        d({
            type: 1
        })
    });
    let C = u.__demoMode ? !1 : c && u.menuState === 0;
    Es(C, y);
    let T = u.__demoMode ? !1 : c && u.menuState === 0;
    js(T, {
        allowed: p.useCallback(() => [u.buttonElement, u.itemsElement], [u.buttonElement, u.itemsElement])
    });
    let se = u.menuState !== 0,
        K = Ps(se, u.buttonElement) ? !1 : A;
    p.useEffect(() => {
        let w = u.itemsElement;
        w && u.menuState === 0 && w !== y ? .activeElement && w.focus({
            preventScroll: !0
        })
    }, [u.menuState, u.itemsElement, y]), As(u.menuState === 0, {
        container: u.itemsElement,
        accept(w) {
            return w.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : w.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT
        },
        walk(w) {
            w.setAttribute("role", "none")
        }
    });
    let Y = Lt(),
        ae = P(w => {
            var le, F, $;
            switch (Y.dispose(), w.key) {
                case j.Space:
                    if (u.searchQuery !== "") return w.preventDefault(), w.stopPropagation(), d({
                        type: 3,
                        value: w.key
                    });
                case j.Enter:
                    if (w.preventDefault(), w.stopPropagation(), d({
                            type: 1
                        }), u.activeItemIndex !== null) {
                        let {
                            dataRef: ge
                        } = u.items[u.activeItemIndex];
                        (F = (le = ge.current) == null ? void 0 : le.domRef.current) == null || F.click()
                    }
                    Kt(u.buttonElement);
                    break;
                case j.ArrowDown:
                    return w.preventDefault(), w.stopPropagation(), d({
                        type: 2,
                        focus: _.Next
                    });
                case j.ArrowUp:
                    return w.preventDefault(), w.stopPropagation(), d({
                        type: 2,
                        focus: _.Previous
                    });
                case j.Home:
                case j.PageUp:
                    return w.preventDefault(), w.stopPropagation(), d({
                        type: 2,
                        focus: _.First
                    });
                case j.End:
                case j.PageDown:
                    return w.preventDefault(), w.stopPropagation(), d({
                        type: 2,
                        focus: _.Last
                    });
                case j.Escape:
                    w.preventDefault(), w.stopPropagation(), G.flushSync(() => d({
                        type: 1
                    })), ($ = u.buttonElement) == null || $.focus({
                        preventScroll: !0
                    });
                    break;
                case j.Tab:
                    w.preventDefault(), w.stopPropagation(), G.flushSync(() => d({
                        type: 1
                    })), _s(u.buttonElement, w.shiftKey ? gt.Previous : gt.Next);
                    break;
                default:
                    w.key.length === 1 && (d({
                        type: 3,
                        value: w.key
                    }), Y.setTimeout(() => d({
                        type: 4
                    }), 350));
                    break
            }
        }),
        J = P(w => {
            switch (w.key) {
                case j.Space:
                    w.preventDefault();
                    break
            }
        }),
        fe = p.useMemo(() => ({
            open: u.menuState === 0
        }), [u.menuState]),
        ie = Ut(h ? x() : {}, {
            "aria-activedescendant": u.activeItemIndex === null || (n = u.items[u.activeItemIndex]) == null ? void 0 : n.id,
            "aria-labelledby": (s = u.buttonElement) == null ? void 0 : s.id,
            id: o,
            onKeyDown: ae,
            onKeyUp: J,
            role: "menu",
            tabIndex: u.menuState === 0 ? 0 : void 0,
            ref: S,
            style: { ...f.style,
                ...v,
                "--button-width": Rs(u.buttonElement, !0).width
            },
            ...Ds(O)
        });
    return q.createElement(Ns, {
        enabled: l ? e.static || A : !1
    }, te({
        ourProps: ie,
        theirProps: f,
        slot: fe,
        defaultTag: jo,
        features: Po,
        visible: K,
        name: "Menu.Items"
    }))
}
let _o = p.Fragment;

function Ro(e, t) {
    let n = p.useId(),
        {
            id: s = `headlessui-menu-item-${n}`,
            disabled: a = !1,
            ...o
        } = e,
        [i, l] = je("Menu.Item"),
        c = i.activeItemIndex !== null ? i.items[i.activeItemIndex].id === s : !1,
        m = p.useRef(null),
        f = ke(t, m);
    V(() => {
        if (!i.__demoMode && i.menuState === 0 && c && i.activationTrigger !== 0) return Os().requestAnimationFrame(() => {
            var T, se;
            (se = (T = m.current) == null ? void 0 : T.scrollIntoView) == null || se.call(T, {
                block: "nearest"
            })
        })
    }, [i.__demoMode, m, c, i.menuState, i.activationTrigger, i.activeItemIndex]);
    let h = Fs(m),
        u = p.useRef({
            disabled: a,
            domRef: m,
            get textValue() {
                return h()
            }
        });
    V(() => {
        u.current.disabled = a
    }, [u, a]), V(() => (l({
        type: 5,
        id: s,
        dataRef: u
    }), () => l({
        type: 6,
        id: s
    })), [u, s]);
    let d = P(() => {
            l({
                type: 1
            })
        }),
        g = P(T => {
            if (a) return T.preventDefault();
            l({
                type: 1
            }), Kt(i.buttonElement)
        }),
        v = P(() => {
            if (a) return l({
                type: 2,
                focus: _.Nothing
            });
            l({
                type: 2,
                focus: _.Specific,
                id: s
            })
        }),
        x = Ws(),
        b = P(T => {
            x.update(T), !a && (c || l({
                type: 2,
                focus: _.Specific,
                id: s,
                trigger: 0
            }))
        }),
        M = P(T => {
            x.wasMoved(T) && (a || c || l({
                type: 2,
                focus: _.Specific,
                id: s,
                trigger: 0
            }))
        }),
        S = P(T => {
            x.wasMoved(T) && (a || c && l({
                type: 2,
                focus: _.Nothing
            }))
        }),
        [y, D] = zt(),
        [A, O] = Bs(),
        C = p.useMemo(() => ({
            active: c,
            focus: c,
            disabled: a,
            close: d
        }), [c, a, d]);
    return q.createElement(D, null, q.createElement(O, null, te({
        ourProps: {
            id: s,
            ref: f,
            role: "menuitem",
            tabIndex: a === !0 ? void 0 : -1,
            "aria-disabled": a === !0 ? !0 : void 0,
            "aria-labelledby": y,
            "aria-describedby": A,
            disabled: void 0,
            onClick: g,
            onFocus: v,
            onPointerEnter: b,
            onMouseEnter: b,
            onPointerMove: M,
            onMouseMove: M,
            onPointerLeave: S,
            onMouseLeave: S
        },
        theirProps: o,
        slot: C,
        defaultTag: _o,
        name: "Menu.Item"
    })))
}
let Do = "div";

function No(e, t) {
    let [n, s] = zt();
    return q.createElement(s, null, te({
        ourProps: {
            ref: t,
            "aria-labelledby": n,
            role: "group"
        },
        theirProps: e,
        slot: {},
        defaultTag: Do,
        name: "Menu.Section"
    }))
}
let Oo = "header";

function Fo(e, t) {
    let n = p.useId(),
        {
            id: s = `headlessui-menu-heading-${n}`,
            ...a
        } = e,
        o = Hs();
    V(() => o.register(s), [s, o.register]);
    let i = {
        id: s,
        ref: t,
        role: "presentation",
        ...o.props
    };
    return te({
        ourProps: i,
        theirProps: a,
        slot: {},
        defaultTag: Oo,
        name: "Menu.Heading"
    })
}
let Wo = "div";

function Bo(e, t) {
    return te({
        ourProps: {
            ref: t,
            role: "separator"
        },
        theirProps: e,
        slot: {},
        defaultTag: Wo,
        name: "Menu.Separator"
    })
}
let Ho = ee(To),
    Lo = ee(Eo),
    $o = ee(Ao),
    Uo = ee(Ro),
    Ko = ee(No),
    zo = ee(Fo),
    qo = ee(Bo),
    ue = Object.assign(Ho, {
        Button: Lo,
        Items: $o,
        Item: Uo,
        Section: Ko,
        Heading: zo,
        Separator: qo
    });

function Go({
    show: e,
    appear: t,
    children: n
}) {
    return r.jsx($s, {
        as: p.Fragment,
        enter: "transition ease-out duration-200",
        enterFrom: "opacity-0 translate-y-1",
        enterTo: "opacity-100 translate-y-0",
        leave: "transition ease-in duration-150",
        leaveFrom: "opacity-100 translate-y-0",
        leaveTo: "opacity-0 translate-y-1",
        show: e,
        appear: t,
        children: n
    })
}
const fn = new ne("transactionEventPlugin"),
    Ve = "prosemirrorDispatchTransaction";

function kt(e, t) {
    const {
        eventTarget: n
    } = fn.getState(e.state);
    return n.addEventListener(Ve, t), () => {
        n.removeEventListener(Ve, t)
    }
}

function Vo(e) {
    return new oe({
        key: fn,
        state: {
            init() {
                return {
                    eventTarget: e
                }
            },
            apply(t, n) {
                return n
            }
        }
    })
}
const xe = new ne("customKeymapPlugin");

function Qo(e, t) {
    e.dispatch(e.state.tr.setMeta(xe, {
        handlers: t
    }))
}

function Yo(e = {
    handlers: {}
}) {
    return new oe({
        key: xe,
        state: {
            init() {
                return { ...e
                }
            },
            apply(t, n) {
                const s = t.getMeta(xe);
                return s ? { ...n,
                    ...s
                } : n
            }
        },
        props: {
            handleKeyDown(t, n) {
                const a = xe.getState(t.state).handlers[n.key];
                return a ? a(n) : !1
            }
        }
    })
}
const X = new ne("menuSelectorPlugin");

function Et(e) {
    e.dispatch(e.state.tr.setMeta(X, {
        active: !1,
        onMenuAction: void 0
    }))
}

function Zr(e, t) {
    e.dispatch(e.state.tr.setMeta(X, {
        active: !0,
        onMenuAction: t
    }))
}

function Jo(e = {
    submitKeys: ["Enter", "Tab"],
    cancelKeys: ["Escape"],
    checkStrictMatchKeys: [" "]
}) {
    return new oe({
        key: X,
        state: {
            init() {
                return { ...e,
                    active: !1
                }
            },
            apply(t, n) {
                const s = t.getMeta(X);
                return s ? { ...n,
                    ...s
                } : n
            }
        },
        props: {
            handleKeyDown(t, n) {
                const s = X.getState(t.state);
                if (!s.active) return !1;
                if (!n.isComposing) return s.submitKeys.includes(n.key) ? (n.preventDefault(), n.stopPropagation(), n.stopImmediatePropagation(), Et(t), s.onMenuAction ? .("submit") ? ? !0) : s.cancelKeys.includes(n.key) ? (n.preventDefault(), s.onMenuAction ? .("cancel"), Et(t), !0) : n.key === "ArrowUp" ? (n.preventDefault(), s.onMenuAction ? .("up"), !0) : n.key === "ArrowDown" ? (n.preventDefault(), s.onMenuAction ? .("down"), !0) : s.checkStrictMatchKeys.includes(n.key) && s.onMenuAction ? .("checkMatch") ? (n.preventDefault(), !0) : !1
            },
            handleDOMEvents: {
                blur: t => {
                    X.getState(t.state).onMenuAction ? .("cancel")
                }
            }
        }
    })
}
const ce = new ne("placeholderPlugin");

function Xo(e) {
    return new oe({
        key: ce,
        state: {
            init() {
                return {
                    placeholder: e
                }
            },
            apply(t, n) {
                return t.getMeta(ce) ? {
                    placeholder: t.getMeta(ce).placeholder
                } : n
            }
        },
        props: {
            decorations(t) {
                const {
                    doc: n
                } = t;
                if (n.childCount === 1 && n.firstChild ? .isTextblock && n.firstChild.content.size === 0) {
                    const a = [],
                        {
                            placeholder: o
                        } = ce.getState(t);
                    return t.doc.descendants((i, l) => {
                        const c = Aa.node(l, l + i.nodeSize, {
                            class: "placeholder",
                            "data-placeholder": o
                        });
                        a.push(c)
                    }), _a.create(n, a)
                }
            }
        }
    })
}
const de = "command_token",
    Zo = {
        group: "inline",
        inline: !0,
        atom: !0,
        content: "text*",
        attrs: {
            id: "",
            hint: ""
        },
        selectable: !1,
        draggable: !1,
        toDOM: e => ["span", {
            "data-mention-id": e.attrs.id,
            "data-mention-hint": e.attrs.hint,
            class: "hint-pill"
        }, e.attrs.hint],
        parseDOM: [{
            tag: "span[data-mention-id][data-mention-hint]",
            getAttrs: e => {
                const t = e.getAttribute("data-mention-id"),
                    n = e.getAttribute("data-mention-hint");
                return {
                    id: t,
                    hint: n
                }
            }
        }]
    };

function gn(e, t) {
    if (e.depth === 0) return;
    const n = e.nodeBefore ? .text ? .match(/(?:^|\s)(\/(\w*))$/);
    if (n ? .[1].length !== void 0) {
        const s = e.pos - n[1].length,
            a = e.pos,
            o = s === t ? .from;
        return {
            range: {
                from: s,
                to: a
            },
            queryText: n[2],
            isDismissed: o
        }
    }
}
const Qe = new ne("systemHintPlugin");

function hn(e, t) {
    return e.setMeta(Qe, t), e
}

function ei(e) {
    const n = e.state.selection.$from,
        s = gn(n, void 0);
    e.dispatch(hn(e.state.tr, { ...Ce(),
        dismissedRange: s ? .range
    }))
}

function Ce() {
    return {
        queryText: "",
        active: !1,
        range: void 0,
        dismissedRange: void 0
    }
}

function er(e, t, n, s, a) {
    const o = e.state.tr;
    hn(o, Ce());
    const i = n + " ",
        l = e.state.schema.nodes[de].create({
            id: t,
            hint: i
        }, e.state.schema.text(i));
    if (a === s) {
        const c = o.doc.resolve(s).nodeAfter;
        if (c ? .isText) {
            const m = c ? .textContent.match(new RegExp(`^(?:${n}) ?`));
            m && (a = s + m[0].length)
        }
    }
    o.replaceWith(s, a, l), o.doc.descendants((c, m) => {
        c.type.name === de && c !== l && (s === 1 && m === s + l.nodeSize || m === 1 && s === m + c.nodeSize ? o.delete(m, m + c.nodeSize) : o.insertText(c.textContent, m, m + c.nodeSize))
    }), e.dispatch(o)
}

function tr(e) {
    const t = e.state.tr;
    t.doc.descendants((n, s) => {
        if (n.type.name === de) {
            const a = s + n.nodeSize;
            s === 1 && t.doc.resolve(a).nodeAfter == null ? t.delete(s, a) : t.insertText(n.textContent, s, s + n.nodeSize)
        }
    }), t.steps.length > 0 && e.dispatch(t)
}

function jt(e) {
    const {
        active: t,
        range: n,
        queryText: s,
        onHintMatch: a
    } = e;
    if (a) return a(!t || !n ? void 0 : {
        text: s,
        range: n
    })
}

function nr(e) {
    const t = [];
    return e.descendants(n => {
        n.type.name === de && typeof n.attrs ? .id == "string" && t.push(n.attrs.id)
    }), t
}

function sr() {
    return new oe({
        key: Qe,
        state: {
            init() {
                return Ce()
            },
            apply(e, t, n, s) {
                const a = e.getMeta(Qe),
                    o = { ...Ce(),
                        ...t,
                        ...a
                    },
                    i = e.selection;
                if (i.from !== i.to || s.doc.eq(n.doc)) return jt(o), o;
                const l = i.$from,
                    c = gn(l, t.dismissedRange);
                return o.active = !!c && !c.isDismissed, c && (o.queryText = c.queryText, o.range = c.range, c.isDismissed && (c.queryText === "" && t.queryText !== "" ? o.dismissedRange = void 0 : o.dismissedRange = c.range)), jt(o), o
            }
        }
    })
}
class vn extends Us {
    constructor(t) {
        super(), this.view = t
    }
    _usedDictation = !1;
    get usedDictation() {
        return this._usedDictation
    }
    set usedDictation(t) {
        this._usedDictation = t
    }
    get element() {
        return this.view.dom
    }
    get document() {
        return this.view.dom.ownerDocument
    }
    isEmpty() {
        return this.view.state.doc.textContent.trim().length === 0
    }
    trimLeadingText(t) {
        const s = this.view.state.tr;
        let a = 0;
        return s.doc.descendants((o, i) => {
            if (o.isText && o.text) {
                if (typeof t == "string" && o.text.startsWith(t)) a = t.length;
                else if (t instanceof RegExp) {
                    const l = o.text.match(t);
                    l ? .index === 0 && (a = l[0].length)
                }
                if (a) {
                    const l = o.text.substring(a).trimStart();
                    a = o.text.length - l.length, s.delete(i, i + a)
                }
            }
            return !o.isLeaf
        }), a > 0 ? (this.view.dispatch(s), !0) : !1
    }
    replaceAll(t, n) {
        const a = this.view.state.tr,
            o = [];
        a.doc.descendants((i, l) => {
            !i.isText || i.text === void 0 || o.push({
                node: i,
                pos: l
            })
        }), o.reverse(), o.forEach(({
            node: i,
            pos: l
        }) => {
            !i.isText || i.text === void 0 || i.text.includes(t) && a.insertText(i.text.replaceAll(t, n), l, l + i.text.length)
        }), this.view.dispatch(a)
    }
    appendText(t) {
        this.view.dispatch(this.view.state.tr.insertText(t))
    }
    delete(t, n) {
        this.view.dispatch(this.view.state.tr.delete(t, n))
    }
    focus() {
        this.view.hasFocus() || (this.view.focus(), this.view.dispatch(this.view.state.tr.setSelection(ve.atEnd(this.view.state.doc)).scrollIntoView()))
    }
    setText(t) {
        const {
            tr: n,
            schema: s
        } = this.view.state, a = t ? s.nodes.paragraph.create(null, s.text(t)) : s.nodes.paragraph.create();
        this.view.dispatch(n.replaceWith(0, this.view.state.doc.content.size, a)), this.view.hasFocus() && this.view.dispatch(this.view.state.tr.setSelection(ve.atEnd(this.view.state.doc)))
    }
    getContentLength() {
        return this.view.state.doc.content.size
    }
    getCurrentText() {
        return this.view.state.doc.textContent
    }
    hasMultipleLines() {
        let t = 0;
        return this.view.state.doc.descendants(n => {
            n.isBlock && t++
        }), t > 1
    }
    getContentToSend() {
        return Ra(this.view)
    }
    resize() {}
    isReady() {
        return !!this.view.state.doc
    }
    setPlaceholder(t) {
        this.view.dispatch(this.view.state.tr.setMeta(ce, {
            placeholder: t
        }))
    }
    getSelectionStart() {
        return this.view.state.selection.ranges[0].$from.pos
    }
    setSelection(t, n) {
        this.view.dispatch(this.view.state.tr.setSelection(ve.create(this.view.state.doc, t, n))), this.view.focus()
    }
    isMenuSelectorActive() {
        return X.getState(this.view.state).active
    }
    registerKeyHandlers(t) {
        Qo(this.view, t)
    }
    acceptLegacyKeydown() {
        return !1
    }
    subscribe(t, n) {
        if (t === "change") {
            const s = () => n(void 0);
            return kt(this.view, s)
        }
        return this.view.dom ? .addEventListener(t, n, {
            capture: !0
        }), () => {
            this.view.dom ? .removeEventListener(t, n, {
                capture: !0
            })
        }
    }
    useState(t) {
        return p.useSyncExternalStore(n => kt(this.view, n), () => t(this), () => t(this))
    }
    getSystemHints() {
        const t = nr(this.view.state.tr.doc)[0];
        return t ? [t] : []
    }
    addSystemHint(t, n, s = 1, a = 1) {
        er(this.view, t, n, s, a)
    }
    removeSystemHints() {
        tr(this.view)
    }
    canShowAutocompletion() {
        return !this.isMenuSelectorActive() && !this.getSystemHints().length
    }
}
const ar = 500;
class N {
    constructor(t, n) {
        this.items = t, this.eventCount = n
    }
    popEvent(t, n) {
        if (this.eventCount == 0) return null;
        let s = this.items.length;
        for (;; s--)
            if (this.items.get(s - 1).selection) {
                --s;
                break
            }
        let a, o;
        n && (a = this.remapping(s, this.items.length), o = a.maps.length);
        let i = t.tr,
            l, c, m = [],
            f = [];
        return this.items.forEach((h, u) => {
            if (!h.step) {
                a || (a = this.remapping(s, u + 1), o = a.maps.length), o--, f.push(h);
                return
            }
            if (a) {
                f.push(new W(h.map));
                let d = h.step.map(a.slice(o)),
                    g;
                d && i.maybeStep(d).doc && (g = i.mapping.maps[i.mapping.maps.length - 1], m.push(new W(g, void 0, void 0, m.length + f.length))), o--, g && a.appendMap(g, o)
            } else i.maybeStep(h.step);
            if (h.selection) return l = a ? h.selection.map(a.slice(o)) : h.selection, c = new N(this.items.slice(0, s).append(f.reverse().concat(m)), this.eventCount - 1), !1
        }, this.items.length, 0), {
            remaining: c,
            transform: i,
            selection: l
        }
    }
    addTransform(t, n, s, a) {
        let o = [],
            i = this.eventCount,
            l = this.items,
            c = !a && l.length ? l.get(l.length - 1) : null;
        for (let f = 0; f < t.steps.length; f++) {
            let h = t.steps[f].invert(t.docs[f]),
                u = new W(t.mapping.maps[f], h, n),
                d;
            (d = c && c.merge(u)) && (u = d, f ? o.pop() : l = l.slice(0, l.length - 1)), o.push(u), n && (i++, n = void 0), a || (c = u)
        }
        let m = i - s.depth;
        return m > rr && (l = or(l, m), i -= m), new N(l.append(o), i)
    }
    remapping(t, n) {
        let s = new Da;
        return this.items.forEach((a, o) => {
            let i = a.mirrorOffset != null && o - a.mirrorOffset >= t ? s.maps.length - a.mirrorOffset : void 0;
            s.appendMap(a.map, i)
        }, t, n), s
    }
    addMaps(t) {
        return this.eventCount == 0 ? this : new N(this.items.append(t.map(n => new W(n))), this.eventCount)
    }
    rebased(t, n) {
        if (!this.eventCount) return this;
        let s = [],
            a = Math.max(0, this.items.length - n),
            o = t.mapping,
            i = t.steps.length,
            l = this.eventCount;
        this.items.forEach(u => {
            u.selection && l--
        }, a);
        let c = n;
        this.items.forEach(u => {
            let d = o.getMirror(--c);
            if (d == null) return;
            i = Math.min(i, d);
            let g = o.maps[d];
            if (u.step) {
                let v = t.steps[d].invert(t.docs[d]),
                    x = u.selection && u.selection.map(o.slice(c + 1, d));
                x && l++, s.push(new W(g, v, x))
            } else s.push(new W(g))
        }, a);
        let m = [];
        for (let u = n; u < i; u++) m.push(new W(o.maps[u]));
        let f = this.items.slice(0, a).append(m).append(s),
            h = new N(f, l);
        return h.emptyItemCount() > ar && (h = h.compress(this.items.length - s.length)), h
    }
    emptyItemCount() {
        let t = 0;
        return this.items.forEach(n => {
            n.step || t++
        }), t
    }
    compress(t = this.items.length) {
        let n = this.remapping(0, t),
            s = n.maps.length,
            a = [],
            o = 0;
        return this.items.forEach((i, l) => {
            if (l >= t) a.push(i), i.selection && o++;
            else if (i.step) {
                let c = i.step.map(n.slice(s)),
                    m = c && c.getMap();
                if (s--, m && n.appendMap(m, s), c) {
                    let f = i.selection && i.selection.map(n.slice(s));
                    f && o++;
                    let h = new W(m.invert(), c, f),
                        u, d = a.length - 1;
                    (u = a.length && a[d].merge(h)) ? a[d] = u: a.push(h)
                }
            } else i.map && s--
        }, this.items.length, 0), new N(qt.from(a.reverse()), o)
    }
}
N.empty = new N(qt.empty, 0);

function or(e, t) {
    let n;
    return e.forEach((s, a) => {
        if (s.selection && t-- == 0) return n = a, !1
    }), e.slice(n)
}
class W {
    constructor(t, n, s, a) {
        this.map = t, this.step = n, this.selection = s, this.mirrorOffset = a
    }
    merge(t) {
        if (this.step && t.step && !t.selection) {
            let n = t.step.merge(this.step);
            if (n) return new W(n.getMap().invert(), n, this.selection)
        }
    }
}
class z {
    constructor(t, n, s, a, o) {
        this.done = t, this.undone = n, this.prevRanges = s, this.prevTime = a, this.prevComposition = o
    }
}
const rr = 20;

function ir(e, t, n, s) {
    let a = n.getMeta(Z),
        o;
    if (a) return a.historyState;
    n.getMeta(ur) && (e = new z(e.done, e.undone, null, 0, -1));
    let i = n.getMeta("appendedTransaction");
    if (n.steps.length == 0) return e;
    if (i && i.getMeta(Z)) return i.getMeta(Z).redo ? new z(e.done.addTransform(n, void 0, s, Se(t)), e.undone, Pt(n.mapping.maps), e.prevTime, e.prevComposition) : new z(e.done, e.undone.addTransform(n, void 0, s, Se(t)), null, e.prevTime, e.prevComposition);
    if (n.getMeta("addToHistory") !== !1 && !(i && i.getMeta("addToHistory") === !1)) {
        let l = n.getMeta("composition"),
            c = e.prevTime == 0 || !i && e.prevComposition != l && (e.prevTime < (n.time || 0) - s.newGroupDelay || !lr(n, e.prevRanges)),
            m = i ? Be(e.prevRanges, n.mapping) : Pt(n.mapping.maps);
        return new z(e.done.addTransform(n, c ? t.selection.getBookmark() : void 0, s, Se(t)), N.empty, m, n.time, l ? ? e.prevComposition)
    } else return (o = n.getMeta("rebased")) ? new z(e.done.rebased(n, o), e.undone.rebased(n, o), Be(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new z(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), Be(e.prevRanges, n.mapping), e.prevTime, e.prevComposition)
}

function lr(e, t) {
    if (!t) return !1;
    if (!e.docChanged) return !0;
    let n = !1;
    return e.mapping.maps[0].forEach((s, a) => {
        for (let o = 0; o < t.length; o += 2) s <= t[o + 1] && a >= t[o] && (n = !0)
    }), n
}

function Pt(e) {
    let t = [];
    for (let n = e.length - 1; n >= 0 && t.length == 0; n--) e[n].forEach((s, a, o, i) => t.push(o, i));
    return t
}

function Be(e, t) {
    if (!e) return null;
    let n = [];
    for (let s = 0; s < e.length; s += 2) {
        let a = t.map(e[s], 1),
            o = t.map(e[s + 1], -1);
        a <= o && n.push(a, o)
    }
    return n
}

function cr(e, t, n) {
    let s = Se(t),
        a = Z.get(t).spec.config,
        o = (n ? e.undone : e.done).popEvent(t, s);
    if (!o) return null;
    let i = o.selection.resolve(o.transform.doc),
        l = (n ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), a, s),
        c = new z(n ? l : o.remaining, n ? o.remaining : l, null, 0, -1);
    return o.transform.setSelection(i).setMeta(Z, {
        redo: n,
        historyState: c
    })
}
let He = !1,
    At = null;

function Se(e) {
    let t = e.plugins;
    if (At != t) {
        He = !1, At = t;
        for (let n = 0; n < t.length; n++)
            if (t[n].spec.historyPreserveItems) {
                He = !0;
                break
            }
    }
    return He
}
const Z = new ne("history"),
    ur = new ne("closeHistory");

function dr(e = {}) {
    return e = {
        depth: e.depth || 100,
        newGroupDelay: e.newGroupDelay || 500
    }, new oe({
        key: Z,
        state: {
            init() {
                return new z(N.empty, N.empty, null, 0, -1)
            },
            apply(t, n, s) {
                return ir(n, s, t, e)
            }
        },
        config: e,
        props: {
            handleDOMEvents: {
                beforeinput(t, n) {
                    let s = n.inputType,
                        a = s == "historyUndo" ? Sn : s == "historyRedo" ? Ye : null;
                    return a ? (n.preventDefault(), a(t.state, t.dispatch)) : !1
                }
            }
        }
    })
}

function xn(e, t) {
    return (n, s) => {
        let a = Z.getState(n);
        if (!a || (e ? a.undone : a.done).eventCount == 0) return !1;
        if (s) {
            let o = cr(a, n, e);
            o && s(t ? o.scrollIntoView() : o)
        }
        return !0
    }
}
const Sn = xn(!1, !0),
    Ye = xn(!0, !0);

function mr() {
    return qe({
        "Shift-Enter": (e, t) => St(e, t),
        Enter: (e, t) => window.innerWidth > Ks[zs.Medium] || Hn ? !1 : St(e, t)
    })
}
const pr = ["p", 0],
    fr = ["br"],
    gr = new Na({
        nodes: {
            paragraph: {
                content: "inline*",
                group: "block",
                parseDOM: [{
                    tag: "p",
                    preserveWhitespace: "full"
                }],
                toDOM() {
                    return pr
                }
            },
            text: {
                group: "inline"
            },
            hard_break: {
                inline: !0,
                group: "inline",
                selectable: !1,
                parseDOM: [{
                    tag: "br"
                }],
                toDOM() {
                    return fr
                }
            },
            [de]: Zo,
            doc: {
                content: "block+"
            }
        },
        marks: {}
    });

function hr() {
    const e = new EventTarget,
        t = new Oa(null, {
            state: Fa.create({
                schema: gr,
                plugins: [dr(), Jo(), Xo(""), sr(), mr(), qe({
                    "Mod-z": Sn,
                    "Mod-y": Ye,
                    "Mod-Shift-z": Ye
                }), Yo(), qe(Wa), Vo(e), Ba()]
            }),
            dispatchTransaction(n) {
                const s = t.state.apply(n);
                t.updateState(s), n.docChanged && e.dispatchEvent(new Event(Ve))
            },
            handlePaste(n, s) {
                const a = s.clipboardData ? .getData("text/plain");
                return a === void 0 ? !1 : (s.defaultPrevented || Ha(n, a), !0)
            },
            clipboardTextSerializer(n) {
                return La(n.content).content
            }
        });
    return t
}

function vr() {
    try {
        return navigator.userAgent.toLocaleLowerCase().includes("firefox")
    } catch {
        return !1
    }
}

function xr() {
    try {
        const e = navigator.userAgent.toLocaleLowerCase();
        return e.includes("safari") && !e.includes("chrome") && !e.includes("firefox")
    } catch {
        return !1
    }
}
const Sr = [Q([qs["prosemirror-parent"], "text-token-text-primary", "max-h-[25dvh]", "max-h-52", "overflow-auto", vr() ? "firefox" : "default-browser"])],
    Je = p.createContext(null),
    wr = ({
        children: e,
        clientThreadId: t
    }) => {
        const n = p.useContext(Je),
            s = p.useMemo(() => n ? ? new vn(hr()), [n, t]);
        return r.jsx(Je.Provider, {
            value: s,
            children: e
        })
    },
    ti = () => $n(p.useContext(Je)),
    ni = ({
        composerController: e,
        placeholder: t
    }) => {
        const n = p.useContext(Ln),
            s = p.useRef(null),
            a = p.useRef(null),
            {
                isMobileOS: o
            } = Gs(),
            i = p.useRef(!1);
        return p.useEffect(() => {
            if (i.current) return;
            if (!(e instanceof vn)) throw new Error(`Expected instance of ProseMirrorComposerController but got ${e.constructor.name}`);
            i.current = !0;
            const l = a.current;
            if (l != null) {
                const {
                    value: c,
                    selectionStart: m,
                    selectionEnd: f
                } = l;
                e.view.dispatch(e.view.state.tr.insertText(c)), e.view.dispatch(e.view.state.tr.setSelection(ve.create(e.view.state.doc, m + 1, f + 1))), l.style.display = "none", l.value = ""
            }
            s.current.appendChild(e.view.dom), e.view.dom.id = Ea, e.view.dom.dataset.virtualkeyboard = "true", ja(e.view.dom), !Vs() && !xr() && requestAnimationFrame(() => {
                e.view.focus()
            })
        }, [e]), p.useEffect(() => {
            e.setPlaceholder(t)
        }, [t, e]), p.useEffect(() => {
            e.logPageMount()
        }, []), r.jsxs("div", {
            ref: s,
            className: Q(Sr),
            children: [r.jsx("textarea", {
                className: "block h-10 w-full resize-none border-0 bg-transparent px-0 py-2 text-token-text-primary placeholder:text-token-text-tertiary",
                autoFocus: !o,
                placeholder: t,
                ref: a,
                "data-virtualkeyboard": !0
            }), r.jsx("script", {
                nonce: n.cspScriptNonce,
                suppressHydrationWarning: !0,
                children: "window.__oai_logHTML?window.__oai_logHTML():window.__oai_SSR_HTML=window.__oai_SSR_HTML||Date.now();requestAnimationFrame((function(){window.__oai_logTTI?window.__oai_logTTI():window.__oai_SSR_TTI=window.__oai_SSR_TTI||Date.now()}))"
            })]
        })
    };

function wn() {
    return {
        caModal: null,
        clientThreadId: "",
        isLoggedInUser: !1,
        focusedObject: null,
        currentModelId: "",
        isModelLoaded: !1,
        isEmbeddedInFocusedView: !1,
        isInstalledApp: !1,
        onNewThread: () => {
            throw new Error("onNewThread not implemented")
        },
        onRequestCompletion: () => {
            throw new Error("onRequestCompletion not implemented")
        },
        onChangeRating: () => {
            throw new Error("onChangeRating not implemented")
        },
        resetThread: () => {
            throw new Error("resetThread not implemented")
        }
    }
}
const bn = p.createContext(wn());

function br() {
    try {
        return p.useContext(bn)
    } catch {
        return wn()
    }
}

function si({
    children: e,
    clientThreadId: t,
    setClientThreadId: n,
    routeType: s,
    prefetchSearchPromises: a
}) {
    const {
        createNewThread: o,
        resetThread: i
    } = Qs({
        clientThreadId: t,
        setClientThreadId: n
    }), {
        data: l
    } = Un(), c = Ys(l), m = Ot(t, y => y ? .modelId), f = Js(), h = c.id, u = m ? ? h, d = ot(), g = Xs(), {
        isUnauthenticated: v
    } = Ze(), x = !v, b = Pa(t), {
        caModal: M,
        onChangeRating: S
    } = Zs({
        clientThreadId: t,
        currentModelId: u
    });
    return r.jsx(bn.Provider, {
        value: {
            caModal: M,
            clientThreadId: t,
            currentModelId: u,
            isModelLoaded: !!m,
            isEmbeddedInFocusedView: f,
            isInstalledApp: d,
            isLoggedInUser: x,
            focusedObject: g,
            onNewThread: o,
            onRequestCompletion: b,
            onChangeRating: S,
            resetThread: i,
            prefetchSearchPromises: a,
            routeType: s
        },
        children: r.jsx(ea, {
            children: r.jsx(wr, {
                clientThreadId: t,
                children: e
            })
        })
    })
}

function U({
    onClick: e,
    href: t,
    target: n,
    children: s,
    disabled: a,
    icon: o,
    testId: i
}) {
    return r.jsx(ue.Item, {
        disabled: a,
        children: ({
            active: l
        }) => r.jsxs(Pe, {
            onClick: e,
            href: t,
            target: n,
            className: Q({
                "bg-token-sidebar-surface-secondary": l,
                "hover:bg-token-sidebar-surface-secondary": !l && !a
            }),
            "data-testid": i,
            children: [o && r.jsx(o, {
                className: "icon-md"
            }), s]
        })
    })
}

function yr({
    to: e,
    children: t,
    icon: n
}) {
    return r.jsx(ue.Item, {
        children: ({
            active: s
        }) => r.jsx(ns, {
            to: e,
            children: r.jsxs(Pe, {
                $as: "span",
                className: Q(s ? "bg-token-sidebar-surface-secondary" : "cursor-pointer"),
                children: [n && r.jsx(n, {
                    className: "icon-md"
                }), t]
            })
        })
    })
}
me.a `p-2 rounded-md hover:bg-black/10 hover:dark:bg-white/10 cursor-pointer`;
const Pe = me.a `flex gap-2 rounded p-2.5 text-sm cursor-pointer focus:ring-0 hover:bg-token-main-surface-secondary radix-disabled:pointer-events-none radix-disabled:opacity-50 group items-center`,
    ai = me(Pe)
`border dark:border-white/20 min-h-0 hover:bg-gray-500/10 h-10 rounded-lg border-[rgba(0,0,0,0.1)]`, Le = me.div `h-px bg-token-border-light my-1.5`, oi = me(Pe)
`${e=>e.$active?"bg-token-sidebar-surface-secondary":"hover:bg-token-sidebar-surface-secondary"} screen-arch:px-2 screen-arch:py-1.5 screen-arch:min-h-[47px]`, Mr = Ft(() => Wt(() =>
    import ("./dgty7ziunhhq6vyd.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])));

function ri({
    onClickSettings: e
}) {
    return r.jsxs(ue, {
        as: "div",
        className: "group relative",
        children: [r.jsx(kr, {}), r.jsx(Go, {
            children: r.jsx(ue.Items, {
                className: "popover absolute bottom-full left-0 z-50 mb-1 w-full overflow-hidden rounded-lg border border-token-border-light bg-token-main-surface-primary p-1.5 shadow-lg outline-none",
                children: r.jsx(Tr, {
                    onClickSettings: e
                })
            })
        })]
    })
}

function yn({
    currentAccount: e
}) {
    const t = !e.isEnterprisey(),
        n = L(),
        s = Ee(),
        a = et();
    return s ? r.jsxs("div", {
        className: "flex items-center justify-between gap-2 py-2 pl-5 pr-4",
        children: [s ? .email && r.jsx("div", {
            className: "text-sm text-token-text-secondary",
            children: s.email
        }), t && r.jsx(pe, {
            label: n.formatMessage(B.addWorkspaceTooltip),
            side: "right",
            children: r.jsx("button", {
                onClick: () => an(a, "profile menu"),
                children: r.jsx(la, {
                    className: "icon-sm text-token-text-primary"
                })
            })
        })]
    }) : null
}

function Cr({
    currentAccount: e
}) {
    return r.jsxs(r.Fragment, {
        children: [r.jsx(yn, {
            currentAccount: e
        }), r.jsx("div", {
            className: "flex h-11 w-full items-center justify-start gap-3 px-3 py-1 text-sm",
            children: r.jsx(Cn, {
                workspace: e,
                isLoading: !1,
                currentWorkspaceId: e.id,
                showCheck: !1
            })
        })]
    })
}

function Mn({
    menuItemComponent: e
}) {
    const t = Gt(),
        n = ss(),
        {
            data: s
        } = Ie(),
        a = Te(s),
        [o, i] = p.useState(!1),
        l = Ee(),
        c = L(),
        m = Kn();
    if (!a || !s) return null;
    const f = a.isWorkspaceAccount(),
        h = s.accountItems.length > 1,
        u = s.accountItems,
        d = zn([u.find(v => v.isPersonalAccount()), ...u.filter(v => !v.isPersonalAccount())]);
    if (d.sort((v, x) => v.isPersonalAccount() ? 1 : x.isPersonalAccount() ? -1 : 0), !h) return f ? r.jsx(Cr, {
        currentAccount: a
    }) : l ? .email && r.jsx("div", {
        className: "ml-3 mr-2 py-2 text-sm text-token-text-secondary",
        children: l.email
    });
    const g = d.map(v => r.jsx(e, {
        disabled: v.isDeactivated(),
        onClick: () => {
            if (v.isDeactivated() || v.id === a ? .id) return;
            i(!0);
            const {
                willRedirect: x
            } = qn(n, v.id, t, c, m);
            x || Gn()
        },
        className: "radix-disabled:pointer-events-auto radix-disabled:hover:bg-transparent",
        children: v.isDeactivated() ? r.jsx(Ir, {
            workspace: v,
            isLoading: o
        }) : r.jsx(Cn, {
            workspace: v,
            isLoading: o,
            currentWorkspaceId: a ? .id
        })
    }, v.id));
    return r.jsxs(r.Fragment, {
        children: [r.jsx(yn, {
            currentAccount: a
        }), r.jsx(k.Separator, {}), g]
    })
}

function Cn({
    workspace: e,
    isLoading: t,
    currentWorkspaceId: n,
    showCheck: s = !0
}) {
    const a = e.canAccessWithCurrentSession,
        o = !t && s && e.id === n;
    return r.jsxs("div", {
        children: [r.jsxs("div", {
            className: "flex w-full items-center gap-2.5",
            children: [r.jsx("span", {
                className: "flex h-5 w-5 items-center justify-center",
                children: r.jsx(rt, {
                    iconSize: "small",
                    workspace: e,
                    className: Q({
                        "flex-shrink-0": !0
                    })
                })
            }), r.jsx("div", {
                className: "line-clamp-1 text-token-text-primary",
                children: Vt(L(), e)
            }), t && r.jsx(Ke, {}), o && r.jsx("span", {
                className: "text-token-text-primary",
                children: r.jsx(Vn, {
                    className: "icon-sm"
                })
            }), !a && r.jsx("span", {
                className: "text-token-text-primary",
                children: r.jsx(Qn, {
                    className: "icon-sm"
                })
            })]
        }), !a && r.jsx("div", {
            className: "rowDivClassName",
            children: r.jsx("small", {
                className: "text-token-text-secondary",
                children: r.jsx(I, { ...e.ssoConnectionName ? B.authenticateWithSSOToAccessWorkspace : B.authenticateWithoutSSOToAccessWorkspace
                })
            })
        })]
    })
}

function Ir({
    workspace: e,
    isLoading: t
}) {
    const n = L(),
        s = e.isOwnerOfAccount(),
        [a, o] = p.useState(!1),
        i = ta(e.id),
        l = e.mustGetSubscriptionBillingCurrency("DeactivatedWorkspaceMenuItem");
    return p.useEffect(() => {
        i != null && a && (H.setPurchaseWorkspaceData({
            minimumSeats: Math.max(i, ht),
            billingDetails: {
                currency: l
            },
            existingAccount: e
        }), o(!1))
    }, [i, a, e, l]), r.jsxs(r.Fragment, {
        children: [r.jsxs(pe, {
            className: "flex w-full flex-1 items-center gap-2.5",
            label: n.formatMessage(B.disabledWorkspaceTooltip),
            sideOffset: 20,
            side: "right",
            children: [r.jsx("span", {
                className: "flex h-5 w-5 items-center justify-center",
                children: r.jsx(na, {
                    className: "icon-sm flex-shrink-0 opacity-30"
                })
            }), r.jsx("div", {
                className: "truncate opacity-30",
                children: Vt(n, e)
            })]
        }), t && r.jsx(Ke, {}), !t && r.jsxs(k.Root, {
            children: [r.jsx(k.Trigger, {
                className: "rounded text-center hover:bg-token-main-surface-secondary",
                children: r.jsx(sa, {
                    className: "icon-sm m-1"
                })
            }), r.jsx(k.Portal, {
                children: r.jsxs(k.Content, {
                    children: [s && r.jsx(r.Fragment, {
                        children: r.jsx(k.Item, {
                            onClick: () => {
                                i == null ? o(!0) : H.setPurchaseWorkspaceData({
                                    minimumSeats: Math.max(i, ht),
                                    billingDetails: {
                                        currency: l
                                    },
                                    existingAccount: e
                                })
                            },
                            children: a ? r.jsx(Ke, {}) : r.jsx(I, {
                                id: "navigation.reactivateWorkspace",
                                defaultMessage: "Reactivate workspace"
                            })
                        })
                    }), r.jsx(k.Item, {
                        onClick: () => {
                            H.setLeaveWorkspaceData(e)
                        },
                        children: r.jsx(I, {
                            id: "navigation.leaveWorkspace",
                            defaultMessage: "Leave workspace"
                        })
                    })]
                })
            })]
        })]
    })
}

function Tr({
    onClickSettings: e
}) {
    const t = Ee(),
        {
            data: n
        } = Ie(),
        s = Te(n),
        a = Qt(),
        {
            clientThreadId: o
        } = br(),
        {
            isDesktopAppAvailable: i,
            isSidekickAvailable: l
        } = it(),
        c = jr(o ? ? "none"),
        {
            openModal: m
        } = Yt();
    var f = s ? .isTeam() ? ? !1;
    if (!s || !n) return null;
    const h = s.isWorkspaceAccount(),
        u = !a;
    return r.jsxs("nav", {
        children: [r.jsx(Mn, {
            menuItemComponent: U
        }), t ? .email && r.jsx(Le, {}), h ? r.jsx(Xt, {
            menuItemComponent: U,
            routedMenuItemComponent: yr
        }) : r.jsx(Jt, {
            menuItemComponent: U
        }), u && r.jsx(U, {
            href: aa(),
            target: "_blank",
            onClick: () => {
                E.logEvent(R.clickFaqLink)
            },
            icon: oa,
            children: r.jsx(I, { ...B.helpAndFaq
            })
        }), r.jsx(U, {
            onClick: e,
            icon: Zt,
            testId: "accounts-settings-button",
            children: r.jsx(I, { ...B.settings
            })
        }), f && r.jsxs(r.Fragment, {
            children: [r.jsx(U, {
                onClick: () => {
                    H.openModal(Me.InviteUsersToWorkspace), E.logEvent(R.accountMemberInviteButton, {
                        location: "dropdown-menu-click"
                    }), we.logEvent("chatgpt_invite_users_to_workspace", 0, {
                        action: "OpenAdminInviteModal",
                        location: "dropdown-menu-click",
                        text: "AddTeammates",
                        step: "OpenModal"
                    })
                },
                icon: en,
                children: r.jsx(I, { ...B.addTeammatesButton
                })
            }), r.jsx(Mr, {
                workspace: s
            })]
        }), (i || c) && r.jsx(Le, {}), i && r.jsx(Er, {
            openDownloadModal: m,
            isSidekickAvailable: l
        }), c && r.jsx(Pr, {}), r.jsx(Le, {}), r.jsx(U, {
            onClick: () => {
                E.logEvent(R.clickLogOut, {
                    eventSource: "mouse"
                }), E.logLogOutButtonClicked({
                    location: "account_switcher_menu"
                }), H.openModal(Me.LogoutConfirm)
            },
            icon: tn,
            children: r.jsx(I, { ...B.logOut
            })
        })]
    })
}

function kr() {
    return Ee() ? r.jsx(Ar, {}) : null
}

function Er({
    openDownloadModal: e,
    isSidekickAvailable: t
}) {
    return r.jsx("span", {
        children: r.jsx(U, {
            icon: nn,
            onClick: () => {
                E.logEvent(R.accountMenuClickDownloadApp), e()
            },
            children: r.jsx(I, { ...t ? B.downloadMacosApp : B.downloadWindowsApp
            })
        })
    })
}
const jr = e => {
        const t = nt(e),
            n = st(t, Xe.Search),
            s = ot();
        return n && at() && !s
    },
    Pr = () => r.jsx("span", {
        children: r.jsx(U, {
            icon: sn,
            onClick: () => {
                window.open(ut), E.logEventWithStatsig(R.chatgptBrowserExtensionUserMenuClicked, "chatgpt_browser_extension_user_menu_clicked")
            },
            children: r.jsx(I, {
                id: "E5VPz/",
                defaultMessage: "Get ChatGPT search extension"
            })
        })
    });

function Ar() {
    const {
        data: e
    } = Ie(), t = Te(e), n = ra(), s = ia(), a = L();
    if (!t || !e) return null;
    const o = t.isWorkspaceAccount(),
        i = e.accountItems.length > 1;
    return r.jsxs(ue.Button, {
        className: "flex w-full max-w-[100%] items-center gap-2 rounded-lg p-2 text-sm hover:bg-token-sidebar-surface-secondary group-ui-open:bg-token-sidebar-surface-secondary",
        "data-testid": "accounts-profile-button",
        "aria-label": a.formatMessage({
            id: "VYC5Ys",
            defaultMessage: "Open profile menu for user {userName} in workspace: {workspaceName}"
        }, {
            userName: s,
            workspaceName: n
        }),
        children: [r.jsx("div", {
            className: "flex-shrink-0",
            style: {
                viewTransitionName: "var(--vt-profile-avatar-sidebar)"
            },
            children: r.jsx(rt, {
                iconSize: "gizmo"
            })
        }), r.jsxs("div", {
            className: "relative -top-px grow -space-y-px truncate text-start text-token-text-primary",
            children: [r.jsx("div", {
                dir: "auto",
                children: s
            }), o || i ? r.jsx("div", {
                className: "truncate text-xs text-token-text-secondary",
                dir: "auto",
                children: n
            }) : null]
        })]
    })
}
const B = Bt({
        helpAndFaq: {
            id: "navigation.helpAndFaq",
            defaultMessage: "Help & FAQ"
        },
        settings: {
            id: "navigation.settings",
            defaultMessage: "Settings"
        },
        logOut: {
            id: "navigation.logOut",
            defaultMessage: "Log out"
        },
        accountSwitcherTitle: {
            id: "navigation.accountSwitcherTitle",
            defaultMessage: "Workspaces"
        },
        defaultWorkspaceTitle: {
            id: "useWorkspaces.defaultWorkspaceTitle",
            defaultMessage: "Untitled Workspace"
        },
        addWorkspaceTooltip: {
            id: "navigation.addWorkspaceTooltip",
            defaultMessage: "Create a Team workspace"
        },
        disabledWorkspaceTooltip: {
            id: "navigation.disabledWorkspaceTooltip",
            defaultMessage: "This workspace has been deactivated"
        },
        downloadMacosApp: {
            id: "navigation.downloadMacApp",
            defaultMessage: "Download the macOS app"
        },
        downloadWindowsApp: {
            id: "navigation.downloadWindowsApp",
            defaultMessage: "Download the Windows app"
        },
        authenticateWithSSOToAccessWorkspace: {
            id: "CV7pdM",
            defaultMessage: "Authenticate with SSO to access this workspace"
        },
        authenticateWithoutSSOToAccessWorkspace: {
            id: "zfCWFh",
            defaultMessage: "Authenticate without SSO to access this workspace"
        },
        addTeammatesButton: {
            id: "inviteMemberButton.inviteMemberButton",
            defaultMessage: "Add Teammates"
        }
    }),
    _r = Ft(() => Wt(() =>
        import ("./dgty7ziunhhq6vyd.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])));

function ii({
    showShareButton: e,
    showProfileDropdown: t,
    clientThreadId: n
}) {
    const s = Xn(n),
        a = L(),
        {
            layer: o
        } = be("1547743984"),
        [i, l, c, m] = Ot(n, b => [De.hasUserMessage(b), De.getGizmoId(b), De.getThreadTitleSource(b), fa(b)]),
        f = rn(l),
        h = c === Zn.NewChat && _t(n),
        u = o.get("show_share_button_text", !1),
        d = a.formatMessage({
            id: "GizmoInformation.shareChat",
            defaultMessage: "Share"
        }),
        g = () => H.openSharingModal(s),
        v = ga(l),
        x = Dt();
    return r.jsxs(r.Fragment, {
        children: [r.jsx(ha, {}), f && h && !i && r.jsx(va, {
            layout: "wide",
            clientThreadId: n
        }), x ? .includes("caterpillar") && r.jsx(Ga, {}), !1, null, e && s && r.jsx(r.Fragment, {
            children: r.jsx(r.Fragment, {
                children: u ? r.jsx(ze, {
                    onClick: g,
                    icon: vt,
                    label: d,
                    "data-testid": "share-chat-button",
                    color: "secondary",
                    className: "text-token-text-primary",
                    style: {
                        viewTransitionName: "var(--vt_share_chat_wide_button)"
                    },
                    children: d
                }) : r.jsx(pe, {
                    label: a.formatMessage({
                        id: "CPEfES",
                        defaultMessage: "Share chat"
                    }),
                    children: r.jsx(ct, {
                        "data-testid": "share-chat-button",
                        onClick: g,
                        icon: vt,
                        style: {
                            viewTransitionName: "var(--vt_share_chat_compact_button)"
                        }
                    })
                })
            })
        }), h && l && v && r.jsx(r.Fragment, {
            children: r.jsx(xa, {
                gizmoId: l
            })
        }), t && r.jsx(Dr, {
            clientThreadId: n
        })]
    })
}

function Rr({
    to: e,
    children: t,
    icon: n
}) {
    const s = et();
    return r.jsx(k.Item, {
        icon: n,
        onSelect: () => s(e),
        children: t
    })
}

function Dr({
    clientThreadId: e
}) {
    const {
        isUnauthenticated: t
    } = Ze();
    return xt.markStart("LoginOrProfileMenu"), xt.markRendered("LoginOrProfileMenu"), t ? r.jsx($r, {}) : r.jsx(Nr, {
        clientThreadId: e
    })
}

function Nr({
    clientThreadId: e
}) {
    const {
        data: t
    } = Ie(), n = Te(t), s = n ? .isPlus() ? ? !1, a = n ? .isWorkspaceAccount() ? ? !1, {
        openSettings: o
    } = ca(), {
        isDesktopAppAvailable: i
    } = it(), l = Wr(e ? ? "none"), {
        openModal: c
    } = Yt(), m = lt(M => !M.isNavCollapsed), {
        layer: f
    } = be("2888142241"), h = L();
    var u = n ? .isTeam() ? ? !1;
    const d = t && Yn(t),
        {
            layer: g
        } = be("2670443078");
    if (!n || !t) return null;
    const v = t.accountItems.length > 1;
    let x = !1;
    !a && !s && d && g.get("is_gating_fix_enabled", !1) && (x = d);
    const b = !a && !x && f.get("is_upgrade_in_settings", !1);
    return ua(), r.jsxs(Jn, {
        triggerButton: r.jsx("button", {
            onClick: () => {
                E.logEvent(R.accountOpenProfileMenu), we.logEvent("chatgpt_account_open_profile_menu")
            },
            "aria-label": h.formatMessage({
                id: "wz2MQV",
                defaultMessage: "Open Profile Menu"
            }),
            "data-testid": "profile-button",
            style: {
                "--legacy-sidebar-offset": m ? "260px" : ""
            },
            className: "flex h-10 w-10 items-center justify-center rounded-full hover:bg-token-main-surface-secondary focus-visible:bg-token-main-surface-secondary focus-visible:outline-0",
            children: r.jsx(rt, {
                iconSize: "medium"
            })
        }),
        children: [v && r.jsx(Mn, {
            menuItemComponent: k.Item
        }), v ? r.jsx(k.Separator, {}) : null, a ? r.jsx(Xt, {
            menuItemComponent: k.Item,
            routedMenuItemComponent: Rr
        }) : r.jsx(Jt, {
            menuItemComponent: k.Item
        }), r.jsx(k.Item, {
            icon: Zt,
            onClick: () => o(),
            "data-testid": "settings-menu-item",
            children: r.jsx(I, {
                defaultMessage: "Settings",
                id: "navigation.settings.0"
            })
        }), r.jsx(k.Separator, {}), u && r.jsxs(r.Fragment, {
            children: [r.jsx(k.Item, {
                "data-testid": "settings-menu-item-invite-teammates",
                onClick: () => {
                    H.openModal(Me.InviteUsersToWorkspace), E.logEvent(R.accountMemberInviteButton, {
                        eventSource: "mouse",
                        location: "profile_drop_down"
                    }), we.logEvent("chatgpt_invite_users_to_workspace", 0, {
                        action: "OpenAdminInviteModal",
                        location: "dropdown-menu-click",
                        text: "AddTeammates",
                        step: "OpenModal"
                    })
                },
                icon: en,
                children: r.jsx(I, { ...In.addTeammatesButton
                })
            }), r.jsx(_r, {
                workspace: n
            })]
        }), i && r.jsx(Fr, {
            openDownloadModal: c
        }), b && r.jsx(Hr, {
            currentAccount: n
        }), l && r.jsx(Br, {}), r.jsxs(r.Fragment, {
            children: [(b || i || l) && r.jsx(k.Separator, {}), r.jsx(k.Item, {
                onClick: () => {
                    E.logEvent(R.clickLogOut, {
                        eventSource: "mouse"
                    }), E.logLogOutButtonClicked({
                        location: "profile_drop_down"
                    }), H.openModal(Me.LogoutConfirm)
                },
                "data-testid": "log-out-menu-item",
                icon: tn,
                children: r.jsx(I, {
                    defaultMessage: "Log out",
                    id: "navigation.logOut.0"
                })
            }), null]
        })]
    })
}

function Or({
    onClick: e,
    className: t,
    testId: n
}) {
    const s = L(),
        a = es(),
        {
            value: o
        } = Rt("4192239497"),
        i = rn(),
        l = a && !i,
        c = l ? s.formatMessage({
            id: "yqd/J5",
            defaultMessage: "Clear chat"
        }) : s.formatMessage({
            id: "OFyxqj",
            defaultMessage: "New chat"
        }),
        m = f => {
            if (!l && o) {
                if (f.metaKey || f.ctrlKey) {
                    E.logEventWithStatsig(R.newChatOpenedInNewTab, "chatgpt_new_chat_opened_in_new_tab");
                    return
                }
                f.preventDefault()
            }
            Ia(window) || H.toggleNavCollapsed(!0), e()
        };
    return r.jsx(pe, {
        sideOffset: 4,
        label: c,
        className: Q("flex", t),
        children: r.jsx(ct, {
            onClick: m,
            icon: l ? Sa : wa,
            "aria-label": c,
            "data-testid": n,
            as: l || !o ? "button" : "link"
        })
    })
}

function li({
    clientThreadId: e,
    hideNewChat: t = !1
}) {
    const [n] = lt(o => [o.activeStageSidebar]), s = on(), a = da({
        clientThreadId: e,
        location: "Navigation actions"
    });
    return !s && !n ? null : r.jsxs("div", {
        className: "flex items-center",
        children: [r.jsx(Lr, {}), !t && r.jsx(Or, {
            onClick: a
        })]
    })
}

function Fr({
    openDownloadModal: e
}) {
    const {
        isSidekickAvailable: t
    } = it();
    return r.jsx("span", {
        children: r.jsx(k.Item, {
            icon: nn,
            onClick: () => {
                e(), E.logEvent(R.accountMenuClickDownloadApp)
            },
            children: t ? r.jsx(I, {
                id: "navigation.downloadMacApp",
                defaultMessage: "Download the macOS app"
            }) : r.jsx(I, {
                id: "navigation.downloadWindowsApp",
                defaultMessage: "Download the Windows app"
            })
        })
    })
}
const Wr = e => {
        const t = nt(e),
            n = st(t, Xe.Search),
            s = ot();
        return n && at() && !s
    },
    Br = () => r.jsx("span", {
        children: r.jsx(k.Item, {
            icon: sn,
            onClick: () => {
                window.open(ut), E.logEventWithStatsig(R.chatgptBrowserExtensionUserMenuClicked, "chatgpt_browser_extension_user_menu_clicked")
            },
            children: r.jsx(I, {
                id: "E5VPz/",
                defaultMessage: "Get ChatGPT search extension"
            })
        })
    });

function Hr({
    currentAccount: e
}) {
    const t = et(),
        n = e ? .hasPaidSubscription(),
        s = e ? .isPlus(),
        a = e ? .isWorkspacePlan(),
        o = e ? .data.subscriptionStatus.planType;
    if (n && !s && !a) return null;
    const i = () => {
        we.logEvent("chatgpt_upgrade_in_settings_menu_clicked", null, {
            current_plan_type: o ? ? "unknown"
        }), E.logEvent(R.upgradeInSettingsMenuClicked, {
            planType: o ? ? "unknown"
        }), an(t, "Upper right settings menu")
    };
    return r.jsx(k.Item, {
        icon: ma,
        onClick: i,
        children: r.jsx(I, {
            id: "navigation.upgradePlan",
            defaultMessage: "Upgrade Plan"
        })
    })
}

function Lr() {
    const e = L(),
        [t] = lt(i => [i.activeStageSidebar]),
        n = on(),
        s = Qt(),
        {
            isUnauthenticated: a
        } = Ze(),
        o = pa(ya, ba, !0, !0);
    return !t && !n || !s || a ? null : r.jsx(pe, {
        label: e.formatMessage({
            id: "cElEQV",
            defaultMessage: "Open sidebar"
        }),
        className: "flex",
        children: r.jsx(ct, {
            "aria-label": e.formatMessage({
                id: "pV/Etp",
                defaultMessage: "Open sidebar"
            }),
            onClick: () => H.toggleNavCollapsed(),
            icon: o
        })
    })
}

function $r() {
    const e = Gt(),
        t = Ma(),
        n = Ca(In.signUpCta),
        {
            layer: s
        } = be("3637408529"),
        a = s.get("is_desktop_primary_auth_button_on_right", !1),
        o = () => {
            e({
                authType: "login",
                callback: f => {
                    E.logLogInButtonClicked({
                        location: "Chat header",
                        provider: f
                    })
                }
            })
        },
        i = () => {
            e({
                authType: "signup",
                callback: f => {
                    E.logSignUpButtonClicked({
                        location: "Chat header",
                        provider: f
                    })
                }
            })
        },
        l = r.jsx(ze, {
            onClick: o,
            color: t ? "primary" : "secondary",
            "data-testid": "login-button",
            className: Q(!t && "screen-arch:hidden md:screen-arch:flex"),
            children: r.jsx(I, {
                id: "B1SN7b",
                defaultMessage: "Log in"
            })
        }, "login"),
        c = r.jsx(ze, {
            color: t ? "secondary" : "primary",
            onClick: i,
            "data-testid": "signup-button",
            className: Q(t && "screen-arch:hidden md:screen-arch:flex"),
            children: r.jsx(I, { ...n
            })
        }, "signup"),
        m = t ? [l, c] : [c, l];
    return r.jsx("div", {
        className: "flex items-center justify-center gap-2",
        children: a ? m.reverse() : m
    })
}
const In = Bt({
    signUpCta: {
        id: "P6cySK",
        defaultMessage: "Sign up"
    },
    addTeammatesButton: {
        id: "inviteMemberButton.inviteMemberButton",
        defaultMessage: "Add Teammates"
    }
});
export {
    wr as C, Lr as E, Dr as L, vo as M, Or as N, Go as P, ho as R, Qr as S, oi as U, si as a, go as b, Nr as c, Pe as d, li as e, Xr as f, bn as g, ai as h, ri as i, ti as j, Ua as k, Yr as l, Jr as m, vn as n, Zr as o, Et as p, ei as q, ni as r, hn as s, ii as t, br as u, mo as x, po as y
};
//# sourceMappingURL=niyc1j17i1iogjjg.js.map